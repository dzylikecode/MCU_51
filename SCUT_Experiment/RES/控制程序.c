#include <reg52.h>

sbit rmotor_cw = P1 ^ 0; //旋转电机正转脉冲口
sbit rmotor_ccw = P1 ^ 1; //旋转电机反转脉冲口

sbit ymotor_cw = P1 ^ 2; // Y轴电机正转脉冲口
sbit ymotor_ccw = P1 ^ 3; // Y轴电机反转脉冲口

sbit xmotor_cw = P1 ^ 4; // X轴电机正转脉冲口
sbit xmotor_ccw = P1 ^ 5; // X轴电机反转脉冲口

sbit origin = P2 ^ 0; // Y轴后退原点
sbit led = P2 ^ 3; //急停灯500Ω

sbit stop_button = P3 ^ 2; //急停按键,外部中断0接口  ok
sbit start_button = P0 ^ 0; //启动按键 ok
sbit r_button = P0 ^ 2; // r启动按键	 ok

bit F_y_cw = 0; // y轴电机正转标志位
bit F_y_ccw = 0; // y轴电机反转标志位
bit F_x_cw = 0; // x轴电机正转标志位
bit F_x_ccw = 0; // x轴电机反转标志位
bit F_r_cw = 0; // r轴电机正转标志位
bit F_r_ccw = 0; // r轴电机反转标志位

bit F_T = 0; //发送数据中间寄存标志位

unsigned int pulno = 0; //脉冲数
unsigned char rxy[6] = { 0, 0, 0, 0, 0, 0 }; //接收上位机数据数组

unsigned char ready_data_t = 0; //给上位机发送数据的寄存器

bit F_origin = 1; //上电询问是否在原点控制标志位
bit F_0 = 0; //开始按键按下程序段控制标志位
bit F_0_1 = 1; //第一次上电后，开始按键状态控制标志位
bit F_1 = 0; //脉冲流程程序段控制标志位
bit F_1_1 = 0; // Y轴电机快进程序段控制标志位
bit F_2 = 0; // Y轴电机快退程序段控制标志位
bit F_3 = 0; //重新开始按键按下程序段控制标志位
bit F_3_1 = 1; //重新开始按键状态控制标志位

bit F_s = 0; //单步运行标志位
bit F_L = 0; //连续运行标志位
bit F_S_L = 0; //单步运行转连续运行标志位

bit F_y = 0; // y轴电机运动程序段的标志位
bit F_x = 0; // x轴电机运动程序段的标志位
bit F_r = 0; // r轴电机运动程序段的标志位

/******************************************************
 *名称：readycommunication_r()
 *功能：接收上位机握手信号子程序
 *输入：无
 *输出：无
 *******************************************************/
void readycommunication_r()
{
    bit i = 1; //中间变量:判断标志位
    unsigned char ready_data_r = 0; //接收握手数据存放变量
    while (i) {
        if (RI == 1) {
            ready_data_r = SBUF; // ready_data_r存接收到的握手数据
            RI = 0; //清除串口接收标志位

            if (ready_data_r == '!') {
                RI = 0;
                i = 0;
                F_0 = 1;
                F_L = 1;
                ES = 1;
            } //连续运行模式
            if (ready_data_r == '$') {
                RI = 0;
                i = 0;
                F_s = 1;
                F_1 = 1;
                ES = 1;
            } //单步运行模式
        }
    }
}

/******************************************************
 *名称：delay1ms()
 *功能：延时1ms子程序
 *输入：所需延时时间
 *输出：无
 *******************************************************/
void delay1ms(unsigned int j)
{
    unsigned int i;
    while (j--) {
        for (i = 0; i < 124; i++) {
            ;
        }
    }
}

/******************************************************
 *名称：fastfeed()
 *功能：快速进给7mm子程序
 *输入：无
 *输出：无
 *******************************************************/
void fastfeed()
{
    TH0 = -125;
    TL0 = -125; //设置T0初值4Khz的频率
    ET0 = 1; //开T0中断
    TR0 = 1; //启动T0

    while (pulno) { } //若计数脉冲数不为零，继续等待定时中断直到脉冲数为0

    if (pulno == 0) {
        TR0 = 0;
    }
}

/******************************************************
 *名称：readycommunication_t()
 *功能：向上位机发送握手信号子程序
 *输入：无
 *输出：无
 *******************************************************/
void readycommunication_t()
{
    bit i = 1; //中间变量:判断标志位
    SBUF = ready_data_t;
    while (i) {
        if (F_T == 1) {
            i = 0; //清除判断标志位
            F_T = 0;
            ready_data_t = 0;
        }
    }
}

/******************************************************
 *名称：r_move()
 *功能：旋转动作子程序
 *输入：无
 *输出：无
 *******************************************************/
void r_move()
{

    TH0 = -250;
    TL0 = -250; //设置T0初值2Khz的频率
    TR0 = 1; //开T0
    while (pulno) //若计数脉冲数不为零，继续等待定时中断直到脉冲数为0
    {
    }
    if (pulno == 0) {
        TR0 = 0; //关T0
        F_r = 0; //退出旋转控制程序段
        F_r_cw = 0; //清除旋转方向控制标志位
        F_r_ccw = 0;
    }
    ready_data_t = 'B'; //旋转完成后，握手发送寄存器写入相应ASC码66（显示为B）
    readycommunication_t(); //发送ASC码66（显示为B）给上位机
}

/******************************************************
 *名称：x_move()
 *功能：x轴动作子程序
 *输入：无
 *输出：无
 *******************************************************/
void x_move()
{

    TH0 = -250;
    TL0 = -250; //设置T0初值2Khz的频率
    TR0 = 1; //开T0
    while (pulno) //若计数脉冲数不为零，继续等待定时中断直到脉冲数为0
    {
    }
    if (pulno == 0) {
        TR0 = 0; //关T0
        F_x = 0; //退出x方向控制程序段
        F_x_cw = 0; //清除方向控制标志位
        F_x_ccw = 0;
    }
    ready_data_t = 'C'; //旋转完成后，握手发送寄存器写入相应ASC码67（显示为C）
    readycommunication_t(); //发送ASC码67（显示为C）给上位机
}

/******************************************************
 *名称：y_move()
 *功能：y轴动作子程序
 *输入：无
 *输出：无
 *******************************************************/
void y_move()
{

    TH0 = -250;
    TL0 = -250; //设置T0初值2Khz的频率
    TR0 = 1; //开T0
    while (pulno) //若计数脉冲数不为零，继续等待定时中断直到脉冲数为0
    {
    }
    if (pulno == 0) {
        TR0 = 0; //关T0
        F_y = 0; //退出y方向控制程序段
        F_y_cw = 0; //清除y方向控制标志位
        F_y_ccw = 0;
    }
    ready_data_t = 'D'; //旋转完成后，握手发送寄存器写入相应ASC码68（显示为D）
    readycommunication_t(); //发送ASC码68（显示为D）给上位机
}

/******************************************************
 *名称：origin_move()
 *功能：y轴动作子程序
 *输入：无
 *输出：无
 *******************************************************/
void origin_move()
{
    F_r_ccw = 1;
    TH0 = -125;
    TL0 = -125; //设置T0初值4Khz的频率

    TR0 = 1; //启动T0

    while (origin == 1) //
    {
    }
    if (origin == 0) {
        TR0 = 0; //关T0
        F_r_ccw = 0;
        ready_data_t = 'E'; //完成后，握手发送寄存器写入相应ASC码69（显示为E）
        readycommunication_t(); //发送ASC码69（显示为E）给上位机
    }
}
/******************************************************
 *名称：main()
 *功能：主程序
 *输入：无
 *输出：无
 *******************************************************/
void main()
{

    //********************************************************
    //主程序段1：设置中断最初值，使其具有明确定义
    IP = 0x01; //设置外部中断0（停止按键信息）中断优先级最高
    TCON = 0x01; //清零标志位，并确定外部中断0为下降沿触发
    IE = 0x81; //总中断开，外部中断0开，其他中断关

    //********************************************************
    //主程序段2：设置串口baud率并启动baud率发生器，允许发送
    TMOD = 0x22; //选定T0&T1为工作方式2(自动装载)
    TH1 = 0xFD;
    TL1 = 0xFD; //设置T1的初值（即波特率9600）
    TR1 = 1; //启动T1工作（启动波特率发生器）
    SCON = 0x50; //串行口工作方式为1(1个起始位0，8个数据位，1个停止位，发送自动加入)；允许串行口接收；发送、接收标志位置0

    rmotor_cw = 1; //使输出口有明确的初值
    rmotor_ccw = 1;
    ymotor_cw = 1;
    ymotor_ccw = 1;
    xmotor_cw = 1;
    xmotor_ccw = 1;
    led = 1;

    //********************************************************
    //主程序段3：上电之后只运行一次，接收并判断上位机单步/连续运行模式,并判断是否在原点的程序段
    while (F_origin) {
        readycommunication_r(); //下位机上电后接收握手信号
        origin = 1; //读外部数据先写1
        delay1ms(20);
        if (origin == 1) {
            origin_move();
        }
        F_origin = 0;
    }

    while (F_L) {
        //*********************************************************
        //主程序段3：下位机上电后接收到正确的上位机握手信号后，开机执行一次，等待开始按键按下
        while (F_0) //第一次开机,等待开始按键按下
        {
            start_button = 1; //要读取数据先向口写1
            if (start_button == 0) {
                delay1ms(30);
                F_0_1 = start_button;
                if (F_0_1 == 0) {
                    F_0 = 0;
                    F_0_1 = 1;
                    F_1_1 = 1;
                }
            }
        }
        //*********************************************************
        //主程序段4：Y轴电机正转快进7mm程序段
        while (F_1_1 == 1) // Y轴电机正转快进7mm控制标志位启动
        {
            F_y_cw = 1; // Y轴电机正转标志位（以便在T0中断中选择是那个脉冲口反转）
            pulno = 28000; //设置快进脉冲数
            fastfeed(); //调用快进子程序
            ready_data_t = 'A'; //快速移动7mm后，握手发送寄存器写入相应ASC码65（显示为A）
            readycommunication_t(); //发送ASC码65（显示为A）给上位机

            F_1_1 = 0; //清除快进程序段控制标志位
            F_1 = 1; //脉冲流程程序段控制标志位置位
            F_y_cw = 0; //清除Y轴电机正转标志位
            F_L = 0;
        }
    }

    //*********************************************************
    //主程序段5：控制电机主要程序段
    while (F_1) {

        //*********************************************************
        //主程序段5.1：旋转运动程序段
        while (F_r == 1) // r电机旋转控制标志位启动
        {
            r_move();
        }
        //*********************************************************
        //主程序段4.3：X轴运动程序段
        while (F_x == 1) // X电机旋转控制标志位启动
        {
            x_move();
        }
        //*********************************************************
        //主程序段4.4：Y轴运动程序段
        while (F_y == 1) // Y电机旋转控制标志位启动
        {
            y_move();
            if (F_s == 1) {
                F_2 = 0;
            } else {
                F_2 = 1;
            }
        }
        //*********************************************************
        //主程序段4.5：Y轴电机反转快退7mm程序段
        while (F_2 == 1) // Y轴电机反转快退7mm控制标志位启动
        {
            F_y_ccw = 1; // Y轴电机反转标志位（以便在T0中断中选择是那个脉冲口反转）
            origin_move();
            F_y_ccw = 0; //清除Y轴电机反转标志位
            F_3 = 1;
        }
        //*********************************************************
        while (F_3 == 1) {
            r_button = 1; //要读取数据先向口写1
            if (r_button == 0) {
                delay1ms(30);
                F_3_1 = r_button;
                if (F_3_1 == 0) {
                    F_3 = 0;
                    F_3_1 = 1;
                    F_L = 1;
                    F_1_1 = 1; //脉冲流程程序段控制标志位置位
                }
            }
        }
        //*********************************************************
    }
    while (F_S_L) {
        ES = 0;
        origin_move();
        F_S_L = 0;
        readycommunication_r(); //下位机上电后接收握手信号
    }
}
/******************************************************
 *名称：time0() interrupt 1 using 1
 *功能：T0中断服务程序。程序里主要进行控制口状态反转以实现合适频率脉冲输出，并对脉冲个数计数。
 *输入：无
 *输出：无
 *******************************************************/
time0() interrupt 1 using 2
{
    if (F_y_cw == 1) {
        ymotor_cw = !ymotor_cw;
    } //产生y轴电机正转脉冲
    if (F_y_ccw == 1) {
        ymotor_ccw = !ymotor_ccw;
    } //产生y轴电机反转脉冲
    if (F_x_cw == 1) {
        xmotor_cw = !xmotor_cw;
    } //产生x轴电机正转脉冲
    if (F_x_ccw == 1) {
        xmotor_ccw = !xmotor_ccw;
    } //产生x轴电机反转脉冲
    if (F_r_cw == 1) {
        rmotor_cw = !rmotor_cw;
    } //产生旋转电机正转脉冲
    if (F_r_ccw == 1) {
        rmotor_ccw = !rmotor_ccw;
    } //产生旋转电机反转脉冲
    if (F_S_L == 1) {
        return;
    }
    pulno--;
}
/******************************************************
 *名称：serialport() interrupt 4 using 1
 *功能：串口中断服务程序
 *输入：无
 *输出：无
 *******************************************************/
serialport() interrupt 4 using 1
{
    unsigned char rno = 0; //数据接收次数计数器
    unsigned char i = 0;

    unsigned int D[4] = { 0, 0, 0, 0 };

    if (TI == 1) {
        TI = 0;
        F_T = 1;
        return;
    }

    rxy[rno] = SBUF;
    if (rxy[0] == '%') {
        F_s = 0;
        F_1 = 0;
        F_S_L = 1;
        rxy[0] = 0;
        rno = 0;
        RI = 0;
        return;
    }
    RI = 0;
    rno++;
    if (rno == 3) {

        rno = 0; //接收次数重新置零
        for (i = 0; i <= 2; i++) // D[1]与D[3]经该程序处理，放置无符号的脉冲数
        {
            D[i] = rxy[i];
            D[i + 1] = rxy[i + 1];
            rxy[i + 1] = rxy[i + 1] & 0xE0; //与0xE0相与，只保留数据的前三位，以确定是哪个轴的正转还是反转
            D[i + 1] = D[i + 1] & 0x01F;
            D[i + 1] <<= 8;
            D[i + 1] = D[i + 1] + D[i];
            i++;
        }
        if (rxy[1] == 0xC0) {
            F_r = 1;
            F_r_cw = 1;
            pulno = D[1] + D[0];
        }
        if (rxy[1] == 0xE0) {
            F_r = 1;
            F_r_ccw = 1;
            pulno = D[1] + D[0];
        }
        if (rxy[1] == 0x40) {
            F_x = 1;
            F_x_cw = 1;
            pulno = D[1] + D[0];
        }
        if (rxy[1] == 0x60) {
            F_x = 1;
            F_x_ccw = 1;
            pulno = D[1] + D[0];
        }
        if (rxy[3] == 0x80) {
            F_y = 1;
            F_y_cw = 1;
            pulno = D[3] + D[2];
        }
        if (rxy[3] == 0xA0) {
            F_y = 1;
            F_y_ccw = 1;
            pulno = D[3] + D[2];
        }
    }
}
/******************************************************
 *名称：int0() interrupt 0 using 3
 *功能：串口中断服务程序
 *输入：无
 *输出：无
 *******************************************************/
int0() interrupt 0 using 3
{

    EA = 0; //关总中断
    F_1 = 0;
    rmotor_cw = 1;
    rmotor_ccw = 1;
    ymotor_cw = 1;
    ymotor_ccw = 1;
    xmotor_cw = 1;
    xmotor_ccw = 1;

    while (1) {
        delay1ms(30);
        led = !led;
    }
}
